# IF688 - Teoria e Implementação de Linguagens Computacionais

## Representações Intermediárias de Código - *Control-flow Graphs*

### Objetivo

O objetivo desta aula é apresentar o conceito de _control-flow graphs_ (CFGs) como uma forma fundamental de representação intermediária em compiladores.
O foco está em compreender o papel dos **blocos básicos** na estrutura do CFG, como o grafo modela o fluxo de execução de um programa, e como construí-lo a partir de representações intermediárias, especialmente código de três endereços (TAC).
A aula também discute diferentes estratégias de construção — recursiva e eficiente — e destaca o uso de CFGs em análises e otimizações de programas.

### Questões para Discussão

- Qual a principal vantagem de utilizar grafos ao invés de árvores como representação intermediária de código? 
- O que são blocos básicos de código e por que são fundamentais?
- Como dividir código em blocos básicos de forma sistemática?
- Como construir um _control-flow graph_ recursivamente a partir de instruções compostas (sequências, if, while)? 
- Como construir um _control-flow graph_ eficientemente diretamente a partir do código de três endereços?
- Quais outras representações visuais de código podem se beneficiar da estrutura de grafos? 


### Material usado em sala de aula

- [Slides](https://drive.google.com/file/d/13X-834SgNHsiyETu7Z1lfmhOufNgha4b/view?usp=sharing)

### Vídeos

- [Representações Intermediárias de Código - Control-Flow Graphs](https://www.youtube.com/watch?v=2BlBPc11PLs)
- [Construindo Control-Flow Graphs a partir de Código de 3 Endereços](https://www.youtube.com/watch?v=lGx9drsIz-g)

### Links Relacionados

- [Control-flow graph](https://en.wikipedia.org/wiki/Control_flow_graph)
- [Dependency graph](https://en.wikipedia.org/wiki/Dependency_graph)
- [Program Dependence Graph](https://en.wikipedia.org/wiki/Program_Dependence_Graph)
- [Call graph](https://en.wikipedia.org/wiki/Call_graph)