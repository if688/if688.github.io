# Tutorial de Implementa√ß√£o ‚Äî Visitors para Extra√ß√£o e Verifica√ß√£o de Tipos em ASTs

## Contexto e objetivo

Neste tutorial, vamos trabalhar com a linguagem **BASIC** utilizada na aula anterior. O objetivo √© aplicar o **padr√£o Visitor** para:

1. **Extrair informa√ß√µes** da AST (por exemplo, montar uma tabela de s√≠mbolos, ou contar declara√ß√µes de vari√°veis);
2. **Verificar tipos** e garantir a consist√™ncia sem√¢ntica do programa (por exemplo, detectar uso de vari√°veis n√£o declaradas ou tipos incompat√≠veis).

Tomaremos como exemplo, mais uma vez, o programa abaixo:

```basic
PROGRAM fibonacci BEGIN
  PRINT "How many fibonacci numbers do you want?"
  DECL nums : INT
  INPUT nums
  DECL a : INT
  DECL b : INT
  DECL c : INT
  LET a = 0
  LET b = 1
  WHILE nums > 0 REPEAT
    PRINT a
    LET c = a + b
    LET a = b
    LET b = c
    LET nums = nums - 1
  ENDWHILE
  PRINT b
ENDPROGRAM
```

> üîó **Arquivos-fonte:**
>
> * [AST](2025-10-30/astnodes.py)
> * [Lexer](2025-10-30/lexer.py)
> * [Parser](2025-10-30/parse.py)
> * [Tabela de S√≠mbolos](2025-10-30/symboltable.py)
> * [Visitors](2025-10-30/visitor.py)
> * [Main](2025-10-30/basic.py)

---

## Revisando a AST 

A **√Årvore Sint√°tica Abstrata (AST)** √© a representa√ß√£o usada para o programa ap√≥s as fases de an√°lise l√©xica e sint√°tica.
A AST criada para esta pequena linguagem separa **comandos (Statements)** e **express√µes (Expressions)**.
Cada constru√ß√£o relevante da linguagem possui uma classe pr√≥pria.

### Estrutura principal: `Program`

```python
class Program(object):
    def __init__(self,name,ls):
        self.name = name   # nome do programa
        self.stmts = ls    # lista de Stmt (comandos)
```

No exemplo do `fibonacci`, o n√≥ raiz `Program` cont√©m:

* `name = "fibonacci"`
* `stmts`: lista de objetos (n√≥s da AST) com os comandos do programa, na ordem em que aparecem (`PRINT`, `DECL`, `INPUT`, `WHILE`, etc.)

---

### Comandos (`Stmt`)

A classe base `Stmt` serve de superclasse para todos os tipos de comandos:

```python
class Stmt(object):
    pass
```

#### Impress√£o (`PrintStmt`)

```python
class PrintStmt(Stmt):
    def __init__(self, exp):
        self.exp = exp   # express√£o a ser impressa
```

#### Leitura (`InputStmt`)

```python
class InputStmt(Stmt):
    def __init__(self, nome):
        self.id = nome # nome da vari√°vel que recebe entrada do usu√°rio
```

#### Declara√ß√£o de vari√°vel (`VarDeclStmt`)

```python
class VarDeclStmt(Stmt):
    def __init__(self, nome, t):
        self.id = nome # nome da vari√°vel declarada (identificador)
        self.type = t # tipo da vari√°vel declarada
```

#### Atribui√ß√£o (`LetStmt`)

```python
class LetStmt(Stmt):
    def __init__(self, nome, e):
        self.id = nome # nome da vari√°vel atribu√≠da (identificador)
        self.exp = e # express√£o a ser avaliada para atribui√ß√£o da vari√°vel
```

#### Estruturas de controle (`IfStmt`, `WhileStmt`, `BlockStmt`)

As estruturas `IF` e `WHILE` tem o comportamento padr√£o. A estrutura `BLOCK` ser√° usada em atividade posterior e permite aninhamento de c√≥digo, onde teremos a possibilidade de declarar, dentro do bloco, vari√°veis que j√° foram declaradas antes, inclusive associando com outro tipo. 

```python
class IfStmt(Stmt):
    def __init__(self, c, corpo):
        self.cond = c
        self.body = corpo

class WhileStmt(Stmt):
    def __init__(self, c, corpo):
        self.cond = c
        self.body = corpo

class BlockStmt(Stmt):
    def __init__(self, nome, corpo):
        self.name = nome
        self.body = corpo
```

### Express√µes (`Expr`)

A classe base √©:

```python
class Expr(object):
    pass
```

#### Express√µes at√¥micas

```python
class IdExpr(Expr):
    def __init__(self, nome):
        self.id = nome

class StringExpr(Expr):
    def __init__(self, s):
        self.str = s

class NumExpr(Expr):
    def __init__(self, valor):
        self.v = valor
```

Esses n√≥s representam nomes de vari√°veis, _strings_ (literais) e n√∫meros inteiros.

#### Express√µes aritm√©ticas

```python
class SumExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class SubExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class MulExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class DivExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right
```

Operadores un√°rios:

```python
class UnaryPlusExpr(Expr):
    def __init__(self, e):
        self.exp = e

class UnaryMinusExpr(Expr):
    def __init__(self, e):
        self.exp = e
```

#### Express√µes booleanas

```python
class EqualsExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class GreaterThanExpr(Expr):
    def __init__(self, left, right):
        self.left = left
        self.right = right

# ... e assim por diante para NotEquals, LessThan, etc.
```

## Lexer e Parser

Os analisadores l√©xico e sint√°tico est√£o prontos e geram a AST automaticamente, conforme j√° visto em aulas anteriores.
O parser √© implementado usando a t√©cnica de _recursive-descent parsing_, com fun√ß√µes para cada um dos s√≠mbolos n√£o terminais, retornando inst√¢ncias das classes de express√£o e comando.

> * [Lexer](2025-10-30/lexer.py)
> * [Parser](2025-10-30/parse.py)

## Tabela de S√≠mbolos

Para verificar tipos, precisamos de uma **tabela de s√≠mbolos**. Ela associa nomes a objetos do tipo `Symbol`.

> üîó **Arquivo:** [SymbolTable](2025-10-30/symboltable.py)

### Estrutura b√°sica

Um s√≠mbolo consiste de um nome (identificador), um tipo, e opcionalmente, um valor (para o caso de construirmos um interpretador).

```python
class Symbol(object):
    def __init__(self, n, t=None, v=None):
        self.name = n
        self.type = t
        self.value = v
```

### Tipos e vari√°veis

Separamos em duas classes para distinguir s√≠mbolos _built-in_ (int, string, boolean) de s√≠mbolos vari√°veis (nomes de vari√°veis).

```python
class BuiltInTypeSymbol(Symbol):
    def __init__(self, n):
        super().__init__(n)

class VarSymbol(Symbol):
    def __init__(self, n, t, v=None):
        super().__init__(n, t, v=v)
```

### A tabela em si

```python
class SymbolTable(object):
    def __init__(self):
        self.symbols = {}
        for primitive in ['INT', 'BOOLEAN', 'STRING']:
            self.insert(primitive, BuiltInTypeSymbol(primitive))

    def insert(self, name, data):
        self.symbols[name] = data

    def lookup(self, name):
        return self.symbols.get(name)
```

Toda tabela come√ßa com `INT`, `BOOLEAN`, e `STRING` j√° registrados, associados como `BuiltInTypeSymbol` correspondente.

## O padr√£o Visitor

Queremos percorrer a AST e executar a√ß√µes dependendo do tipo de n√≥.
Em vez de escrever um monte de `if isinstance(node, ...)`, usamos **despacho din√¢mico** (_dynamic dispatch_): o m√©todo a ser chamado √© inferido automaticamente pelo nome da classe.

### Classe base `NodeVisitor`

```python
class NodeVisitor(object):
    def visit(self, node):
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))
```

Se o objeto for `PrintStmt`, o m√©todo chamado ser√° `visit_PrintStmt`. Se n√£o houver m√©todo correspondente, chamamos `generic_visit`, que lan√ßa exce√ß√£o.

## `GenericVisitor`: o esqueleto do percurso

Essa classe percorre a AST inteira, mas **n√£o faz nada** ‚Äî
ela √© a base para criar _visitors_ mais espec√≠ficos.

```python
class GenericVisitor(NodeVisitor):
    def __init__(self, tree):
        self.ast = tree

    def traverse(self):
        self.visit(self.ast)

    def erro(self, msg):
        raise Exception(msg)
```

### M√©todos de visita (exemplos)

```python
def visit_Program(self,node):
    for stmt in node.stmts:
        self.visit(stmt)

def visit_PrintStmt(self,node):
    self.visit(node.exp)

def visit_LetStmt(self,node):
    self.visit(node.exp)

def visit_WhileStmt(self,node):
    self.visit(node.cond)
    for stm in node.body:
        self.visit(stm)
```

E assim por diante para cada tipo de n√≥. O racioc√≠nio e ideia por tr√°s √© de que `GenericVisitor` √© um **template**. Criamos _visitors_ concretos herdando desta classe e redefinindo apenas o necess√°rio.

## Exemplo simples: contar vari√°veis

Como `CountVars` herda de `GenericVisitor`, n√£o precisamos implementar nenhum outro m√©todo `visit_...`, sem preju√≠zo √† corretude. A √∫nica coisa que nos interessa, se queremos contar declara√ß√µes de vari√°veis, √© monitorar o que acontece ao encontrarmos um n√≥ do tipo `VarDeclStmt`. 

```python
class CountVars(GenericVisitor):
    def __init__(self, tree):
        super().__init__(tree)
        self.numVars = 0

    def visit_VarDeclStmt(self, node):
        self.numVars += 1
```

Como usar:

```python
ast = Parser(Lexer(codigo)).parse()
counter = CountVars(ast)
counter.traverse()
print("N√∫mero de vari√°veis declaradas:", counter.numVars)
```

## Primeira passada: constru√ß√£o da tabela de s√≠mbolos

Agora, criamos um _visitor_ que varre o programa e **registra todas as vari√°veis declaradas** na tabela de s√≠mbolos.

```python
class BuildSymbolTable(GenericVisitor):
    def __init__(self, tree):
        super().__init__(tree)
        self.symbolTable = SymbolTable()

    def buildTable(self):
        self.traverse()
        return self.symbolTable

    def visit_VarDeclStmt(self, node):
        nome = node.id
        if self.symbolTable.lookup(nome) is not None:
            self.erro('Vari√°vel ' + nome + ' j√° foi declarada.')
        tipo = self.symbolTable.lookup(node.type)
        simbolo = VarSymbol(nome, tipo)
        self.symbolTable.insert(nome, simbolo)
```

---

## Segunda passada: verifica√ß√£o de tipos

Usamos agora um novo _visitor_ para verificar **consist√™ncia de tipos e declara√ß√µes**.

```python
class TypeCheckVisitor(GenericVisitor):
    def __init__(self, tree):
        super().__init__(tree)
        builder = BuildSymbolTable(tree)
        self.symbolTable = builder.buildTable()

    def typecheck(self):
        self.traverse()
        return True
```

### M√©todos auxiliares

```python
def INT(self):     return self.symbolTable.lookup('INT')
def BOOLEAN(self): return self.symbolTable.lookup('BOOLEAN')
def STRING(self):  return self.symbolTable.lookup('STRING')
```

### Express√µes simples

```python
def visit_NumExpr(self, node):
    return self.INT()

def visit_StringExpr(self, node):
    return self.STRING()

def visit_IdExpr(self,node):
    simbolo = self.symbolTable.lookup(node.id)
    if simbolo is None:
        self.erro(f'vari√°vel {node.id} n√£o foi declarada')
    return simbolo.type
```

### Opera√ß√µes aritm√©ticas e booleanas

```python
def visit_SumExpr(self, node):
    tL = self.visit(node.left)
    tR = self.visit(node.right)
    if tL == tR == self.INT():
        return self.INT()
    self.erro(f'Tipos incompat√≠veis: {tL} e {tR}')

def visit_GreaterThanExpr(self, node):
    tL = self.visit(node.left)
    tR = self.visit(node.right)
    if tL == tR == self.INT():
        return self.BOOLEAN()
    self.erro(f'Tipos incompat√≠veis: {tL} e {tR}')
```

### Condicionais e la√ßos

```python
def visit_IfStmt(self, node):
    t = self.visit(node.cond)
    if t != self.BOOLEAN():
        self.erro('Condi√ß√£o do IF deve ser booleano')
    for stm in node.body:
        self.visit(stm)

def visit_WhileStmt(self, node):
    t = self.visit(node.cond)
    if t != self.BOOLEAN():
        self.erro('Condi√ß√£o do WHILE deve ser booleano')
    for stm in node.body:
        self.visit(stm)
```

### Atribui√ß√µes e entrada

```python
def visit_LetStmt(self, node):
    simbolo = self.symbolTable.lookup(node.id)
    if simbolo is None:
        self.erro(f'Vari√°vel n√£o foi declarada: {node.id}')
    tVar = simbolo.type
    tExp = self.visit(node.exp)
    if tVar != tExp:
        self.erro(f'Tipos incompat√≠veis em LET: {tVar} e {tExp}')

def visit_InputStmt(self, node):
    if self.symbolTable.lookup(node.id) is None:
        self.erro(f'vari√°vel {node.id} n√£o foi declarada')
```

> **Arquivo completo:** [visitor.py](2025-10-30/visitor.py)

---

## 9Ô∏è‚É£ Testando: verifica√ß√£o do programa `fibonacci`

### C√≥digo de teste

```python
# main_typecheck.py
from lexer import Lexer
from parser import Parser
from visitor import TypeCheckVisitor

codigo = """PROGRAM fibonacci BEGIN
  PRINT "How many fibonacci numbers do you want?"
  DECL nums : INT
  INPUT nums
  DECL a : INT
  DECL b : INT
  DECL c : INT
  LET a = 0
  LET b = 1
  WHILE nums > 0 REPEAT
    PRINT a
    LET c = a + b
    LET a = b
    LET b = c
    LET nums = nums - 1
  ENDWHILE
  PRINT b
ENDPROGRAM
"""

ast = Parser(Lexer(codigo)).parse()
checker = TypeCheckVisitor(ast)
print("Type check:", checker.typecheck())
```

### Sa√≠da esperada

```
Type check: True
```

Se alterarmos o c√≥digo para, por exemplo:

```basic
LET a = "x"
```

A sa√≠da ser√°:

```
Exception: Tipos incompat√≠veis em LET: <<INT>> e <<STRING>>
```

---

## Aten√ß√£o

* Mantenha o Visitor **imut√°vel** (n√£o altere a AST durante a visita).
* Teste com programas curtos e erros intencionais.
* N√£o se esque√ßa de **inserir os tipos primitivos** antes das vari√°veis.
* Evite comparar tipos por string (`'INT'`); compare **objetos Symbol**.

### Extens√µes sugeridas

* Permitir `STRING + STRING`.
* Adicionar `TRUE` e `FALSE` como literais booleanos.